(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{427:function(e,t,v){"use strict";v.r(t);var a=v(2),_=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_1、变化侦测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、变化侦测"}},[e._v("#")]),e._v(" 1、变化侦测")]),e._v(" "),t("blockquote",[t("p",[e._v("Vue.js最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的JavaScript对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回避一些常见的问题。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("                                                                       ——官方文档\n")])])])]),e._v(" "),t("p",[e._v("从状态生成DOM，在输出到用户界面显示的一整套流程叫做渲染，应用在运行时会不断地进行重新渲染。")]),e._v(" "),t("p",[e._v("而响应式系统赋予框架重新渲染的能力， 其最重要组成部分是【变化侦测】。变化侦测是响应式系统的核心，没有它就没有重新渲染。 在框架运行时，视图也就无法随着状态的变化而变化。")]),e._v(" "),t("p",[e._v("变化侦测的作用是侦测数据的变化。当数据变化时，会通知视图进行相应的更新。")]),e._v(" "),t("p",[t("strong",[e._v("变化侦测的实现原理")])]),e._v(" "),t("ul",[t("li",[e._v("Object的变化侦测")]),e._v(" "),t("li",[e._v("Array的变化侦测")]),e._v(" "),t("li",[e._v("变化侦测相关的API实现原理")])]),e._v(" "),t("h1",{attrs:{id:"_2、object的变化侦测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、object的变化侦测"}},[e._v("#")]),e._v(" 2、Object的变化侦测")]),e._v(" "),t("blockquote",[t("p",[e._v("Object和Array的变化侦测采用不同的处理方式。")])]),e._v(" "),t("p",[e._v("问：那他们的变化侦测不同的处理方式差异点在哪里？")]),e._v(" "),t("p",[e._v("问： 在javascript中，如何侦测一个对象的变化？")]),e._v(" "),t("p",[e._v("问：Object.defineProperty和ES6的Proxy的原理是什么？有什么差异，优劣势分别是什么？")]),e._v(" "),t("h2",{attrs:{id:"_2-1-什么是变化侦测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-什么是变化侦测"}},[e._v("#")]),e._v(" 2.1 什么是变化侦测")]),e._v(" "),t("p",[e._v("Vue.js的渲染过程是声明式的，通过模版来描述状态与DOM之间的映射关系。")]),e._v(" "),t("p",[e._v("Vue的特点是声明式，根据侦测数据的变化， 通过不同的状态， 通知试图显示。")]),e._v(" "),t("p",[e._v("变化侦测解决的问题是：在运行时应用内部的状态会不断发生变化，需要不停地重新渲染，如何确定状态中发生了变化？")]),e._v(" "),t("p",[e._v("变化侦测两种类型：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("“推”（push）")]),e._v(" "),t("ul",[t("li",[e._v('Vue.js的变化侦测是属于"推"')]),e._v(" "),t("li",[e._v("主动，状态发生变化时，立刻就是道了。 在一定程度上知道哪些状态变了。")]),e._v(" "),t("li",[e._v("粒度细")])])]),e._v(" "),t("li",[t("p",[e._v("“拉”（pull）")]),e._v(" "),t("ul",[t("li",[e._v("Angular和React的变化侦测都是属于“拉”")]),e._v(" "),t("li",[e._v("被动")]),e._v(" "),t("li",[e._v("粒度最粗")])])])]),e._v(" "),t("p",[e._v("粒度越细，每个状态所绑定的依赖就越多， 依赖追踪在内存上的开销就会越大。")]),e._v(" "),t("p",[e._v("vue2.0采用虚拟DOM，将粒度调整为[中等粒度]，即一个状态的绑定的依赖不再是具体的DOM节点，而是一个组件。")]),e._v(" "),t("p",[e._v("状态变化话后，就会通知到组件， 组件内部再使用虚拟DOM进行比对。")]),e._v(" "),t("p",[e._v("（大大降低了依赖数量， 从而降低依赖追踪所消耗的内存。）")]),e._v(" "),t("p",[e._v('Vue能随意调整力度， 本质上还要归功于变化侦测。因为"推"类型的变化侦测可以随意调整粒度。')]),e._v(" "),t("h2",{attrs:{id:"_2-2-如何追踪变化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-如何追踪变化"}},[e._v("#")]),e._v(" 2.2 如何追踪变化")]),e._v(" "),t("p",[e._v("JavaScript中，如何侦测一个对象的变化？")]),e._v(" "),t("p",[e._v("有两种方法：")]),e._v(" "),t("ul",[t("li",[e._v("使用Object.deineProperty")]),e._v(" "),t("li",[e._v("ES6的Proxy")])]),e._v(" "),t("p",[e._v("Vue实现变化侦测的原理：")]),e._v(" "),t("ul",[t("li",[e._v("Vue2.0 用Object.defineProperty")]),e._v(" "),t("li",[e._v("Vue3.0 用 ES6 Proxy")])]),e._v(" "),t("p",[t("code",[e._v("Object.defineProperty")])]),e._v(" "),t("ul",[t("li",[e._v("劫持方式：只能劫持对象的属性，不能直接代理对象")]),e._v(" "),t("li",[e._v("流程：get中进行依赖收集，set数据时通知订阅者更新")]),e._v(" "),t("li",[e._v("存在的问题：虽然"),t("code",[e._v("Object.defineProperty")]),e._v("通过为属性设置"),t("code",[e._v("getter/setter")]),e._v("能够完成数据的响应式，但它并不算是实现数据的响应式的完美方案，某些情况下需要对其进行修补或者hack，这也是它的缺陷， 主要表现在两个方面：")])]),e._v(" "),t("ul",[t("li",[t("ul",[t("li",[e._v("无法检测到对象属性的新增或删除")]),e._v(" "),t("li",[e._v("不能监听数组的新增变化")])])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function defineReactive(data,key,val){\n  Object.defineProperty(data,key,{\n    enumerable:true,\n    configurable:true,\n    get:function(){\n      return val\n    },\n    set:function(){\n      if(val === newVal){\n        return\n      }\n      val = newVal\n    }\n   })\n}\n")])])]),t("p",[e._v("定义一个响应式数据"),t("code",[e._v("defineReactive")]),e._v("函数，在函数中进行变化追踪，封装后需要只需要传递data、key和val就行了。")]),e._v(" "),t("p",[t("code",[e._v("Proxy")])]),e._v(" "),t("ul",[t("li",[e._v("劫持方式：代理整个对象，只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性")]),e._v(" "),t("li",[e._v("本质："),t("code",[e._v("Proxy")]),e._v("本质上属于元编程非破坏性数据劫持，在原对象的基础上进行了功能的衍生而又不影响原对象， 符合松耦合高内聚的设计理念")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let obj = new Proxy({},{\n  get:function(target,propKey,value,receiver){\n     console.log(`getting${propKey}`)\n     return Reflect.get(target,propKey,receiver)\n  },\n  set:function(target,propKey,value,receiver){\n    console.log(`setting${propKey}`)\n    return Reflect.set(target,propKey,receiver)\n  }\n})\n")])])]),t("p",[e._v("\\")]),e._v(" "),t("h2",{attrs:{id:"_2-3-如何收集依赖"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-如何收集依赖"}},[e._v("#")]),e._v(" 2.3 如何收集依赖")]),e._v(" "),t("p",[e._v("先收集依赖，即把用到数据name的地方收集起来，然后等属性发生变化时，把之前收集好的依赖循环触发一遍就好了。")]),e._v(" "),t("p",[e._v("一句话总结："),t("strong",[e._v("在getter中收集依赖，在setter中触发依赖。")])]),e._v(" "),t("h2",{attrs:{id:"_2-4-依赖收集在哪里"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-依赖收集在哪里"}},[e._v("#")]),e._v(" 2.4 依赖收集在哪里")]),e._v(" "),t("p",[e._v("收集到Dep中")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function defineReactive(data,key,val){\n  let dep = []//新增\n  Object.defineProperty(data,key,{\n    enumerable:true,\n    configurable:true,\n    get:function(){\n      dep.push(window.target) //新增\n      return val\n    },\n    set:function(){\n      if(val === newVal){\n        return\n      }\n      // 新增\n      for(let i=0;i<dep.length;i++){\n        dep[i](newVal,val)\n      }\n      val = newVal\n    }\n   })\n}\n")])])]),t("h2",{attrs:{id:"_2-5-依赖是谁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-依赖是谁"}},[e._v("#")]),e._v(" 2.5 依赖是谁")]),e._v(" "),t("p",[e._v("收集的依赖是"),t("code",[e._v("window.target")]),e._v("，收集谁呢？当属性发生变化后， 通知谁。")]),e._v(" "),t("h2",{attrs:{id:"_2-6-什么是watcher"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-什么是watcher"}},[e._v("#")]),e._v(" 2.6 什么是Watcher")]),e._v(" "),t("p",[e._v("Watcher是一个中介的角色，数据发生变化时通知它，然后它再通知其他地方。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// keypath\n\nvm.$watch('a.b.c',function(newVal,oldVal){\n  //do something\n})\n")])])]),t("p",[e._v("\\")]),e._v(" "),t("p",[e._v("当'data.a.b.c'属性变化 的时候， 触发第二个参数中的函数。")]),e._v(" "),t("p",[e._v("如何实现上述功能？")]),e._v(" "),t("ul",[t("li",[e._v("把这个watcher实例添加到"),t("code",[e._v("data.a.b.c")]),e._v(" 属性的Dep中就可以了")]),e._v(" "),t("li",[e._v("然后当"),t("code",[e._v("data.a.b.c")]),e._v("的值发生变化时候，就会通知"),t("code",[e._v("Watcher")])]),e._v(" "),t("li",[e._v("Watcher再执行参数中的这个回调函数。")])]),e._v(" "),t("p",[e._v("如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export default class Watcher{\n  constructor(vm,expOrFn,cb){\n    this.vm = vm;\n    //执行this.getter(),就可以读取data.a.b.c的内容\n    this.getter = parsePath(expOrFn);\n    this.cb = cb;\n    this.value = this.get();\n  }\n  \n  get(){\n    window.target = this; //将window.target设置为当前的watcher实例\n    let value = this.getter.call(this.vm,this.vm) // 读data.a.b.c的值，就会触发getter\n    window.target = undefined\n    return value\n  }\n  \n  update(){\n    const oldValue = this.value\n    this.value = this.get()\n    this.cb.call(this.vm,this.value,oldValue)\n  }\n}\n")])])]),t("p",[e._v("触发了"),t("code",[e._v("getter")]),e._v("，就会触发收集依赖的逻辑。而关于收集依赖，上面已经介绍了，会从"),t("code",[e._v("window.target")]),e._v("中读取一个依赖并添加到"),t("code",[e._v("Dep")]),e._v("中。")]),e._v(" "),t("p",[e._v("依赖注入到"),t("code",[e._v("Dep")]),e._v("中后，每当"),t("code",[e._v("data.a.b.c")]),e._v("的值发生变化时，就会让依赖列表中所有的依赖循环触发"),t("code",[e._v("update")]),e._v("方法，也就是Watcher中的update方法。而"),t("code",[e._v("update")]),e._v("方法会执行参数中的回调函数，将"),t("code",[e._v("value和oldValue")]),e._v("传到参数中。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const bailER = /[^\\w.$]/\nexport function parsePath(path){\n  if(bailRE,test(path)){\n    return\n  }\n  const segments = path.split('.)\n  return function(obj){\n    for(let i=0; i< segments.length;i++){\n      if(!obj) return\n      obj = obj[segments[i]]\n    }\n    return obj\n  }\n}\n")])])]),t("p",[e._v("先将"),t("code",[e._v("keypath")]),e._v("用 . 分割成数组，然后循环数组一层一层去读数据，最后拿到的"),t("code",[e._v("obj")]),e._v("就是"),t("code",[e._v("keypath")]),e._v("中想要读的数据。")]),e._v(" "),t("h2",{attrs:{id:"_2-7-递归侦测所有key"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-7-递归侦测所有key"}},[e._v("#")]),e._v(" 2.7 递归侦测所有key")]),e._v(" "),t("p",[e._v("希望把数据中的所有属性（包括子属性）都侦测到，所以要封装一个"),t("code",[e._v("Observer")]),e._v("类。这个类的作用是将一个数据内的所有属性（包括子属性）都转换成"),t("code",[e._v("getter/setter")]),e._v("的形式，然后去追踪它们的变化：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export class Observer{\n  constructor (value){\n    this.value = value\n    \n    if(!Array.isArray(value)){\n      this.walk(value)\n    }\n  }\n  \n  walk(obj){\n    const keys = Object.keys(obj)\n    for(let i=0;i<keys.length;i++){\n      defineReactive(obj,keys[i],obj[keys[i]])\n    }\n  }\n}\n\n\nfunction defineReactive(data,key,val){\n  //新增递归子属性\n  if(typeof val === 'object'){\n    new Observer(val)\n  }\n  let dep = []//新增\n  Object.defineProperty(data,key,{\n    enumerable:true,\n    configurable:true,\n    get:function(){\n      dep.push(window.target) //新增\n      return val\n    },\n    set:function(){\n      if(val === newVal){\n        return\n      }\n      // 新增\n      for(let i=0;i<dep.length;i++){\n        dep[i](newVal,val)\n      }\n      val = newVal\n    }\n   })\n}\n")])])]),t("ul",[t("li",[e._v("定义了"),t("code",[e._v("Observer")]),e._v("类，它用来将一个正常的object转换成被侦测的object。")]),e._v(" "),t("li",[e._v("然后判断数据的类型，只有"),t("code",[e._v("Object")]),e._v("类型的数据才会调用"),t("code",[e._v("walk")]),e._v("将每一个属性转换成"),t("code",[e._v("getter/setter")]),e._v("的形式来侦测变化。")]),e._v(" "),t("li",[e._v("最后，在"),t("code",[e._v("defineReactive")]),e._v("中新增"),t("code",[e._v("new Observer(val)")]),e._v("来递归子属性，这样我们就可以把data中的所有属性（包括子属性）都转换成"),t("code",[e._v("getter/setter")]),e._v("的形式来侦测变化。")])]),e._v(" "),t("p",[t("strong",[e._v("只要将一个object传到Observer中，那么这个object就会变成响应式的object。")])]),e._v(" "),t("h2",{attrs:{id:"_2-8-关于object的问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-8-关于object的问题"}},[e._v("#")]),e._v(" 2.8 关于Object的问题")]),e._v(" "),t("p",[e._v("前面介绍了"),t("code",[e._v("Object")]),e._v("类型数据的变化侦测原理，了解了数据的变化是通过"),t("code",[e._v("getter/setter")]),e._v("来追踪的。也正是由于这种追踪方式，有些语法中即便是数据发生了变化，"),t("code",[e._v("Vue.js")]),e._v("也追踪不到。")]),e._v(" "),t("p",[e._v("与其说是"),t("code",[e._v("Object")]),e._v("的问题，不如说是"),t("code",[e._v("Object.defineProperty")]),e._v("的问题， 通过这个实现的侦测，是侦测不到一下情况的变化的。")]),e._v(" "),t("ul",[t("li",[e._v("像object添加属性")]),e._v(" "),t("li",[e._v("从object中删除一个属性")])]),e._v(" "),t("p",[e._v("为了解决这个问题，Vue.js提供了两个API——"),t("code",[e._v("vm.$set")]),e._v("与"),t("code",[e._v("vm.$delete")]),e._v("方法。")]),e._v(" "),t("h1",{attrs:{id:"_3、思考总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、思考总结"}},[e._v("#")]),e._v(" 3、思考总结")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("变化侦测，就是侦测数据的变化。 当数据发生变化时，能侦测到并发出通知。")])]),e._v(" "),t("li",[t("p",[e._v("Object可以通过Object.defineProperty将属性转换为getter/setter的形式来追踪变化，读取数据时会触发getter，修改数据的时候会触发setter。")])]),e._v(" "),t("li",[t("p",[e._v("收集依赖需要为依赖找一个存储依赖的地方，为此我们创建了Dep，它用来收集依赖、删除依赖和向依赖发送消息等。")])]),e._v(" "),t("li",[t("p",[e._v("所谓的依赖，其实就是Watcher。只有Watcher触发的getter才会收集依赖，哪个Watcher触发了getter，就把哪个Watcher收集到Dep中。当数据发生变化时，会循环依赖列表，把所有的Watcher都通知一遍。")])]),e._v(" "),t("li",[t("p",[e._v("Watcher的原理")]),e._v(" "),t("ul",[t("li",[e._v("先把自己设置到全局唯一的指定位置（例如window.target），然后读取数据")]),e._v(" "),t("li",[e._v("因为读取了数据，所以会触发这个数据的getter")]),e._v(" "),t("li",[e._v("接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个Watcher收集到Dep中去。")]),e._v(" "),t("li",[e._v("接着，在getter中就会从全局唯一的那个位置读取当前正在读取数据的Watcher，并把这个Watcher收集到Dep中去")])])]),e._v(" "),t("li",[t("p",[e._v("我们创建了Observer类，它的作用是把一个object中的所有数据（包括子数据）都转换成响应式的，也就是它会侦测object中所有数据（包括子数据）的变化。")])])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/038fb8301e42405fa145554046f35348~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),e._v(" "),t("p",[e._v("图解：")]),e._v(" "),t("ul",[t("li",[e._v("Data通过Observer转换为getter/setter的形式来追踪变化。")]),e._v(" "),t("li",[e._v("当外界通过Watcher读取数据时，会触发getter从而将Watcher添加到依赖中。")]),e._v(" "),t("li",[e._v("当数据发生变化时候， 会触发setter，从而向Dep中的依赖（Watcher）发送通知")]),e._v(" "),t("li",[e._v("Watcher接受到通知后， 会向外界发送通知， 变化通知到外界后可能会触发视图更新，也有可能会触发用户的某个回调函数。")])]),e._v(" "),t("p",[e._v("阅读本章节的时候， 随着引发的几个问题：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("问：那他们（Object和Array）的变化侦测不同的处理方式差异点在哪里？")])]),e._v(" "),t("li",[t("p",[e._v("问： 在javascript中，如何侦测一个对象的变化？")]),e._v(" "),t("ul",[t("li",[e._v("看完本章问题得到解决，可以用Object.defineProperty属性来实现。")])])]),e._v(" "),t("li",[t("p",[e._v("问：Object.defineProperty和ES6的Proxy的原理是什么？有什么差异，优劣势分别是什么？")])])])])}),[],!1,null,null,null);t.default=_.exports}}]);