(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{433:function(e,_,v){"use strict";v.r(_);var r=v(2),t=Object(r.a)({},(function(){var e=this,_=e._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言：")]),e._v(" "),_("p",[e._v("本篇文章纯属个人看书学习的学习笔记， 有不妥的地方请多多评论指导～")]),e._v(" "),_("ul",[_("li",[e._v("学习Array的变化侦测")]),e._v(" "),_("li",[e._v("Array是如何追踪变化")]),e._v(" "),_("li",[e._v("在Array中拦截器是如使用")]),e._v(" "),_("li",[e._v("收集依赖")]),e._v(" "),_("li",[e._v("获取Observer实力")]),e._v(" "),_("li",[e._v("侦测Array的新增和元有元素的变化")])]),e._v(" "),_("h1",{attrs:{id:"_1、array的变化侦测"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、array的变化侦测"}},[e._v("#")]),e._v(" 1、Array的变化侦测")]),e._v(" "),_("p",[e._v("举例子:")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("this.list.push(1)\n")])])]),_("p",[e._v("在Object中的侦测方式是通过"),_("code",[e._v("getter/setter")]),e._v("实现的，但是上面这个例子使用了"),_("code",[e._v("push")]),e._v("方法来改变数组，并不会触发"),_("code",[e._v("getter/setter")]),e._v("方法。")]),e._v(" "),_("p",[_("strong",[e._v("因为可以通过"),_("code",[e._v("Array")]),e._v("原型上的方法来改变数组的内容， 所以"),_("code",[e._v("Object")]),e._v("那种通过"),_("code",[e._v("getter/setter")]),e._v("的实现方式就行不通了。")])]),e._v(" "),_("h1",{attrs:{id:"_2、array如何追踪变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、array如何追踪变化"}},[e._v("#")]),e._v(" 2、Array如何追踪变化")]),e._v(" "),_("p",[e._v("注意：ES6之前，"),_("code",[e._v("JavaScript")]),e._v("并没有提供元编程的能力， 也就是"),_("strong",[e._v("没有提供可以拦截原型方法的能力。")]),e._v(" 但是我们"),_("strong",[e._v("可以用自定义的方法去覆盖原生的原型方法。")])]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("例如：用一个拦截器去覆盖"),_("code",[e._v("Array.prototype")]),e._v("。之后每当使用Array原型上的方法操作数组的时候， 都是执行的是拦截器中提供的方法。这样通过拦截器，我们就可以追踪到Array的变化了.")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1956a15fd4ca4d518d2540b12d3ec05e~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),e._v(" "),_("p",[e._v("使用拦截器覆盖原生方法。")]),e._v(" "),_("h1",{attrs:{id:"_3、拦截器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、拦截器"}},[e._v("#")]),e._v(" 3、拦截器")]),e._v(" "),_("p",[e._v("如何实现这个拦截器？拦截器其实就是一个和"),_("code",[e._v("Array.prototype")]),e._v("一样的"),_("code",[e._v("Object")]),e._v(",里面包含的属性一摸一样，只不过这个"),_("code",[e._v("Object")]),e._v("中某些可以改变数组自身内容的方法是我们"),_("strong",[e._v("处理过的")]),e._v("。")]),e._v(" "),_("p",[e._v("在JavaScript中， Array原型上可以改变数组自身内容的方法有7个："),_("code",[e._v("push、pop、shift、unshift、splice、sort和reverse.")])]),e._v(" "),_("p",[e._v("实现拦截器的代码如下：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("const arrayProto = Array.prototype\nexport const arrayMethods = Object.create(arrayProto)\n\n;[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n].forEach((method)=>{\n  //缓存原始方法\n  const original = arrayProto[method]\n  Object.defineProperty(arrayMethods,method,{\n    value:function mutator(...args){\n      return original.apply(this,args)\n    },\n    enumerable:false,\n    writable:true,\n    configurable:true\n  })\n})\t\n")])])]),_("p",[_("code",[e._v("arrayMethods")]),e._v("继承自"),_("code",[e._v("Array.prototype")]),e._v("，拥有它的所有功能。用"),_("code",[e._v("arrayMethods")]),e._v("去覆盖`Array.prototype.")]),e._v(" "),_("p",[e._v("arrayMethods"),_("code",[e._v("上使用")]),e._v("Object.defineProperty`方法将可以改变原数组自身内容的方法进行封装。")]),e._v(" "),_("p",[e._v("当使用push方法的时候， 其实是调用的"),_("code",[e._v("arrayMethods.push")]),e._v("，对应的就是执行"),_("code",[e._v("mutator")]),e._v("函数。")]),e._v(" "),_("p",[e._v("在"),_("code",[e._v("mutator")]),e._v("执行"),_("code",[e._v("original")]),e._v("即原生"),_("code",[e._v("Array.prototype")]),e._v("上的方法， 来做它对应该做的事儿。")]),e._v(" "),_("p",[e._v("所以，我们可以在"),_("code",[e._v("mutator")]),e._v("函数中做一些其他的事儿， 例如新增发送变化的通知等。")]),e._v(" "),_("h1",{attrs:{id:"_4、使用拦截器覆盖array原型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4、使用拦截器覆盖array原型"}},[e._v("#")]),e._v(" 4、使用拦截器覆盖Array原型")]),e._v(" "),_("p",[e._v("想要让拦截器生效， 就需要用它去覆盖"),_("code",[e._v("Array.prototype")]),e._v("。但是又不能直接去覆盖，因为这样会污染全局的"),_("code",[e._v("Array")]),e._v(".")]),e._v(" "),_("p",[e._v("实际上希望拦截只针对哪些被侦测了变化的数据生效，换句话说就是希望拦截器只能覆盖哪些响应式数组的原型（例如7个可以改变原数组的方法）。")]),e._v(" "),_("p",[e._v("将数据变成响应式的， 需要通过"),_("code",[e._v("Observer")]),e._v("，所以只要在"),_("code",[e._v("Observer")]),e._v("中使用拦截器覆盖那些即将被转换为响应式"),_("code",[e._v("Array")]),e._v("类型数据的原型就可以了。")]),e._v(" "),_("p",[e._v("例如：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("export class Observer{\n  constructor(value){\n    this.value = value;\n    \n    if(Array.isArray(value)){ //新增兼容数组\n      value.__proto__ = arrayMethods\n    }else{\n      this.walk(value)\n    }\n  }\n}\n")])])]),_("p",[e._v("\\")]),e._v(" "),_("p",[_("code",[e._v("value.__proto__ = arrayMethods")]),e._v(" 的作用就是将拦截器（加工后具备拦截功能的"),_("code",[e._v("arrayMethods")]),e._v("）赋值给"),_("code",[e._v("value.__proto__")]),e._v("，通过"),_("code",[e._v("__proto__")]),e._v("可以巧妙地实现覆盖value原型的功能。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c49acfc81684b99875d7128931421d1~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),e._v(" "),_("p",[_("code",[e._v("__proto__")]),_("strong",[e._v("是"),_("code",[e._v("Object.getPrototypeOf")]),e._v(" 和 "),_("code",[e._v("Object.setPrototypeOf")]),e._v("的早期实现，所以使用ES6中的，"),_("code",[e._v("Object.setPrototypeOf")]),e._v("来代替")]),e._v(" "),_("code",[e._v("__proto__")]),e._v(" "),_("strong",[e._v("完全可以实现一样的效果。")])]),e._v(" "),_("p",[e._v("\\")]),e._v(" "),_("h1",{attrs:{id:"_5、将拦截器方法挂载到数组的属性上"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5、将拦截器方法挂载到数组的属性上"}},[e._v("#")]),e._v(" 5、将拦截器方法挂载到数组的属性上")]),e._v(" "),_("p",[_("code",[e._v("__proto__")]),e._v("访问原型的方式，并不是所有浏览器都支持， 所以我们需要处理不能使用"),_("code",[e._v("__proto__")]),e._v("的情况 "),_("strong",[e._v("。")])]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("Vue的做法很简单粗暴：如果不能使用 "),_("code",[e._v("__proto__")]),e._v(" "),_("strong",[e._v("，")]),e._v(" 就直接讲"),_("code",[e._v("arrayMethods")]),e._v("身上的这些方法设置到被侦测的数组上：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("import {arrayMethods} from './array'\n\n//判断__proto__是否可用\nconst hasProto = '__proto__' in {}\nconst arrayKeys = Object.getOwnPropertyNames(arrayMethods)\n\nexport class Observer{\n  constructor(value){\n    this.value = value;\n    \n    if(Array.isArray(value)){ //新增兼容数组\n      const augment = hasPro\n         ? protoAugment\n         : copyAugment\n      augment(value,arrayMethods,arrayKey)\n    }else{\n      this.walk(value)\n    }\n  }\n  ...\n}\n  \n\nfunction protoAugment(target,src,keys){\n  target.__proto__ = src\n}\n\nfunction copyAugment(target,src,keys){\n  for(let i=0,l=keys.length; i<l;i++){\n    const key = keys[i]\n    def(target,key,src[key])\n  }\n}\n")])])]),_("p",[_("code",[e._v("hasProto")]),e._v("判断浏览器是否支持"),_("code",[e._v("__proto__")]),e._v(" "),_("strong",[e._v("：")]),e._v(" 如果支持则用"),_("code",[e._v("protoAugment")]),e._v("来覆盖原型；如果不支持，则调用"),_("code",[e._v("copyAugment")]),e._v("函数将拦截器挂在到value上。")]),e._v(" "),_("p",[_("img",{attrs:{src:"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9645ecbb37c346b0ad18895fb80b7e7a~tplv-k3u1fbpfcp-zoom-1.image",alt:""}})]),e._v(" "),_("p",[e._v("当访问一个对象的方法是你， 只有其自身不存在这个方法，才回去它的原型上找到这个方法。")]),e._v(" "),_("h1",{attrs:{id:"_6、如何收集依赖"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6、如何收集依赖"}},[e._v("#")]),e._v(" 6、如何收集依赖")]),e._v(" "),_("p",[e._v("之所以创建拦截器，"),_("strong",[e._v("本质上是为了得到一种能力，一种当数组的内容发生变化时得到通知的能力")]),e._v("。")]),e._v(" "),_("p",[_("strong",[e._v("Object中，是在"),_("code",[e._v("defineReactive")]),e._v("中的"),_("code",[e._v("getter")]),e._v("里使用Dep收集的，每个"),_("code",[e._v("key")]),e._v("都会有一个对应的"),_("code",[e._v("Dep")]),e._v("列表来存储依赖。")])]),e._v(" "),_("hr"),e._v(" "),_("p",[e._v("==> 在getter中收集依赖，依赖被存储在Dep里")]),e._v(" "),_("p",[e._v("而数组在哪里收集依赖？")]),e._v(" "),_("ul",[_("li",[e._v("数组也是在getter")]),e._v(" "),_("li",[e._v("而"),_("code",[e._v("Array")]),e._v("的依赖和"),_("code",[e._v("Object")]),e._v("一样，也在"),_("code",[e._v("defineReactive")]),e._v("中收集：")]),e._v(" "),_("li",[_("code",[e._v("Array")]),e._v("在"),_("code",[e._v("getter")]),e._v(" 中收集依赖， 在拦截器中触发依赖")])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("function defineReactive(data,key,val){\n  if(typeof val === 'object') new Observer(val)\n  let dep = new Dep();\n  Object.defineProperty(data,key,{\n    enumerable:true,\n    configurable:true,\n    get:function(){\n      dep.depend();//在这里收集Array的依赖\n      return val;\n    },\n    set:function(newVal){\n      if(val === newVal){\n        return\n      }\n      dep.notify()\n      val = newVal\n    }\n  })\n}\t\n")])])]),_("h1",{attrs:{id:"_7、依赖列表存在哪儿"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7、依赖列表存在哪儿"}},[e._v("#")]),e._v(" 7、依赖列表存在哪儿")]),e._v(" "),_("p",[_("code",[e._v("Vue.js")]),e._v("把"),_("code",[e._v("Array")]),e._v("的依赖存放在"),_("code",[e._v("Observer")]),e._v("中：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("export class Observer{\n  constructor(value){\n    this.value = value\n    this.dep = new Dep() //新增Dep\n    if(Array.isArray(value)){\n    \n      const augment = hasProto ? protoAugment:copyAugment\n      augment(value,arrayMethods,arrayKey)\n    }else{\n      this.walk(value)\n    }\n  }\n  ...\n}\n")])])]),_("p",[e._v("为什么数组的"),_("code",[e._v("dep")]),e._v("（依赖）要保存在"),_("code",[e._v("Observer")]),e._v("实例上呢？")]),e._v(" "),_("ul",[_("li",[e._v("因为"),_("code",[e._v("getter")]),e._v("中可以访问到"),_("code",[e._v("Observe")]),e._v("实例")]),e._v(" "),_("li",[e._v("同时在"),_("code",[e._v("Array")]),e._v("拦截器中也可以访到"),_("code",[e._v("Observe")]),e._v("实例")])]),e._v(" "),_("h1",{attrs:{id:"_8、收集依赖"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8、收集依赖"}},[e._v("#")]),e._v(" 8、收集依赖")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("function defineReactive(data,key,val){\n  let childOb = observe(val) //修改\n  let dep = new Dep();\n  Object.defineProperty(data,key,{\n    enumerable:true,\n    configurale:true,\n    get:function(){\n      dep.depend()\n      \n      //新增\n      if(childOb){\n        childOb.dep.depend();\n      }\n      return val;\n    }\n    set:function(newVal){\n      if(val === newVal) return\n      dep.notify()\n      val = newVal\n    }\n  })\n  \n}\n")])])]),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("// 尝试为value创建一个Observer实例\n// 如果创建成功，直接返回新创建的Observer实例\n// 如果value已经存在一个Observer实例，则直接返回它\n\nexport function observe(value,asRootData){\n  if(!isObject(value)) return\n  let ob\n  if(hasOwn(value,'__ob__') && value.__ob__ instanceof Observer){\n    ob = value.__ob__\n  }else{\n    ob = new Observer(value)\n  }\n  return ob;\n}\n")])])]),_("p",[e._v("上述代码中， 新增了函数"),_("code",[e._v("observe")]),e._v("：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("observe")]),e._v("函数尝试创建一个"),_("code",[e._v("Observer")]),e._v("实例")]),e._v(" "),_("li",[e._v("如果"),_("code",[e._v("value")]),e._v("已经是响应式数据， 则不需要再次创建"),_("code",[e._v("Observer")]),e._v("实例")]),e._v(" "),_("li",[e._v("已有时，直接返回已创建的"),_("code",[e._v("Observer")]),e._v("实例，避免重复侦测"),_("code",[e._v("value")]),e._v("变化的问题。")])]),e._v(" "),_("p",[e._v("通过这样的方式可以为数组收集依赖。")]),e._v(" "),_("h1",{attrs:{id:"_9、在拦截器中获取observer实例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9、在拦截器中获取observer实例"}},[e._v("#")]),e._v(" 9、在拦截器中获取Observer实例")]),e._v(" "),_("p",[e._v("如何在拦截器中访问"),_("code",[e._v("Observer")]),e._v("实例？")]),e._v(" "),_("ul",[_("li",[e._v("因为"),_("code",[e._v("Array")]),e._v("拦截器是对原型的一种封装，所以可以在拦截器中访问到"),_("code",[e._v("this")]),e._v("（当前正在被操作的数组）")]),e._v(" "),_("li",[_("code",[e._v("dep")]),e._v("保存在"),_("code",[e._v("Observer")]),e._v("中，所以需要在"),_("code",[e._v("this")]),e._v("上读到"),_("code",[e._v("Observer")]),e._v("的实例")])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("//工具函数\nfunction def(obj,key,val,enumerable){\n  Object.defineProperty(obj,key,{\n    value:val,\n    enumerable:!!enumerable,\n    writable:true,\n    configurable:true,\n  })\n}\n\nexport class Observer{\n  constructor(value){\n    this.value = value;\n    this.dep = new Dep();\n    def(value,'__ob__',this)\n    \n    if(Array.isArray(value)){\n      const augment = hasProto ? protoAugment:copyAugment;\n      augment(value,arrayMethods,arrayKey)\n    }else {\n      this.walk(value)\n    }\n  }\n  ...\n}\n")])])]),_("p",[e._v("在"),_("code",[e._v("Observer")]),e._v("中新增了一段代码，它可以在"),_("code",[e._v("value")]),e._v("上新增一个不可枚举的属性 "),_("code",[e._v("__ob__")]),e._v("，这个属性的值就是当前"),_("code",[e._v("Observer")]),e._v("的实例。")]),e._v(" "),_("p",[e._v("之后就可以通过数组数据的 "),_("code",[e._v("__ob__")]),e._v("属性拿到"),_("code",[e._v("Observer")]),e._v("实例，然后就可以拿到 "),_("code",[e._v("__ob__")]),e._v("上的"),_("code",[e._v("dep")]),e._v("。")]),e._v(" "),_("p",[_("code",[e._v("__ob__")]),e._v("还可以用来标记当前value是否已经被Observer转换成了响应式数据。")]),e._v(" "),_("p",[e._v("换句话说：")]),e._v(" "),_("ul",[_("li",[e._v("所有被侦测了变化的数据身上都会有一个"),_("code",[e._v("__ob__")]),e._v("属性来表示它们是响应式的。")]),e._v(" "),_("li",[e._v("通过"),_("code",[e._v("__ob__")]),e._v("判断")])]),e._v(" "),_("ul",[_("li",[_("ul",[_("li",[e._v("如果value是响应式的，则直接返回 "),_("code",[e._v("__ob__")])]),e._v(" "),_("li",[e._v("如果不是响应式的，则使用"),_("code",[e._v("new Observer")]),e._v("来将数据转换成响应式数据。")])])])]),e._v(" "),_("ul",[_("li",[e._v("当value身上被标记了"),_("code",[e._v("__ob__")]),e._v("之后，就可以通过"),_("code",[e._v("value.__ob__")]),e._v("来访问"),_("code",[e._v("Observer")]),e._v("实例")]),e._v(" "),_("li",[e._v("如果是Array拦截器，因拦截器是原型方法")])]),e._v(" "),_("ul",[_("li",[_("ul",[_("li",[e._v("可直接通过"),_("code",[e._v("this.__ob__")]),e._v("来访问"),_("code",[e._v("Observer")]),e._v("实例。")])])])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v(";[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n].forEach((method)=>{\n  //缓存原始方法\n  const original = arrayProto[method]\n  Object.defineProperty(arrayMethods,method,{\n    value:function mutator(...args){\n      const ob = this.__ob__ //新增\n      return original.apply(this,args)\n    },\n    enumerable:false,\n    writable:true,\n    configurable:true\n  })\n})\t\n")])])]),_("p",[e._v("我们在mutator函数里通过this."),_("strong",[e._v("ob")]),e._v(" 来获取Observer实例。")]),e._v(" "),_("h1",{attrs:{id:"_10、向数组的依赖发送通知"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10、向数组的依赖发送通知"}},[e._v("#")]),e._v(" 10、向数组的依赖发送通知")]),e._v(" "),_("p",[e._v("当侦测到数组发生变化时，会向依赖发送通知。")]),e._v(" "),_("ul",[_("li",[e._v("首先要可以访问到依赖。")]),e._v(" "),_("li",[e._v("在拦截器中访问"),_("code",[e._v("Observer")]),e._v("实例")]),e._v(" "),_("li",[e._v("只需在"),_("code",[e._v("Observer")]),e._v("实例中拿到"),_("code",[e._v("dep")]),e._v("属性")]),e._v(" "),_("li",[e._v("最后直接发通知即可")])]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v(";[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n].forEach((method)=>{\n  //缓存原始方法\n  const original = arrayProto[method]\n  dep(arrayMethods,method,function mutator(...args){\n    const result = original.apply(this,args)\n    const ob = this.__ob__\n    ob.dep.notify() //向依赖发送消息\n    return result;\n  })\n})\t\n")])])]),_("p",[e._v("上面的代码中，我们调用了"),_("code",[e._v("ob.dep.notify()")]),e._v("去通知依赖"),_("code",[e._v("（Watcher）")]),e._v("数据发生了改变。")]),e._v(" "),_("h1",{attrs:{id:"_11、侦测数组中元素的变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11、侦测数组中元素的变化"}},[e._v("#")]),e._v(" 11、侦测数组中元素的变化")]),e._v(" "),_("p",[e._v("所有响应式数据的子数据都要侦测，不论是Object中的数据还是Array中的数据。")]),e._v(" "),_("p",[e._v("如何侦测"),_("strong",[e._v("所有数据子集")]),e._v("的变化？")]),e._v(" "),_("p",[e._v("在Observer中新增一些处理， 让其可以将Array也转换成响应式的：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("export class Observer{\n  constructor(value){\n    this.value = value;\n    def(value,'__ob__',this)\n    \n  \n    if(Array.isArray(value)){ //新增兼容数组\n      this.observerArray(value)\n    }else{\n      this.walk(value)\n    }\n  }\n  ...\n}\n  \n//侦测Array中的每一项\n observerArray(items){\n   for(let i=0,l=items.length;i<l;i++){\n     observe(items[i])\n   }\n   ...\n }\n")])])]),_("p",[e._v("这里新增了"),_("code",[e._v("observeArray")]),e._v("方法,")]),e._v(" "),_("ul",[_("li",[e._v("其作用是循环"),_("code",[e._v("Array")]),e._v("中的每一项，")]),e._v(" "),_("li",[e._v("执行"),_("code",[e._v("observe")]),e._v("函数来侦测变化。")])]),e._v(" "),_("p",[e._v("前面介绍过"),_("code",[e._v("observe")]),e._v("函数，其实就是将数组中的每个元素都执行一遍"),_("code",[e._v("new Observer")]),e._v("，这很明显是一个递归的过程。")]),e._v(" "),_("h1",{attrs:{id:"_12、侦测新增元素的变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12、侦测新增元素的变化"}},[e._v("#")]),e._v(" 12、侦测新增元素的变化")]),e._v(" "),_("h2",{attrs:{id:"_12-1-获取新增元素"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-获取新增元素"}},[e._v("#")]),e._v(" 12.1 获取新增元素")]),e._v(" "),_("p",[e._v("在上面的代码中，我们通过"),_("code",[e._v("switch")]),e._v("对"),_("code",[e._v("method")]),e._v("进行判断，如果"),_("code",[e._v("method")]),e._v("是"),_("code",[e._v("push")]),e._v("、"),_("code",[e._v("unshift")]),e._v("、"),_("code",[e._v("splice")]),e._v("这种可以新增数组元素的方法，那么从"),_("code",[e._v("args")]),e._v("中将新增元素取出来，暂存在"),_("code",[e._v("inserted")]),e._v("中。")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v(";[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n].forEach((method)=>{\n  //缓存原始方法\n  const original = arrayProto[method]\n  def(arrayMethods,method,function mutator(...args){\n    const result = original.apply(this,args)\n    const ob = this.__ob__\n    let inserted\n    switch(method){\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2)\n        break;\n    }\n    ob.dep.notify() //向依赖发送消息\n    return result;\n  })\n})\t\n")])])]),_("p",[e._v("接下来，我们要使用"),_("code",[e._v("Observer")]),e._v("把"),_("code",[e._v("inserted")]),e._v("中的元素转换成响应式的。")]),e._v(" "),_("h2",{attrs:{id:"_12-2-使用observer侦测新增元素"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-使用observer侦测新增元素"}},[e._v("#")]),e._v(" 12.2 使用Observer侦测新增元素")]),e._v(" "),_("p",[e._v("我们可以在拦截器中通过"),_("code",[e._v("this")]),e._v("访问到"),_("code",[e._v("__ob__")]),e._v("，然后调用 "),_("code",[e._v("__ob__")]),e._v("上的"),_("code",[e._v("observeArray")]),e._v("方法就可以了:")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v(";[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n].forEach((method)=>{\n  //缓存原始方法\n  const original = arrayProto[method]\n  def(arrayMethods,method,function mutator(...args){\n    const result = original.apply(this,args)\n    const ob = this.__ob__\n   \n    let inserted\n    switch(method){\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break;\n      case 'splice':\n        inserted = args.slice(2)\n        break;\n    }\n    if(inserted) ob.observeArray(inserted) //新增\n    ob.dep.notify() //向依赖发送消息\n    return result;\n  })\n})\t\n")])])]),_("p",[e._v("上述代码中，我们从"),_("code",[e._v("this.__ob__")]),e._v(" 上拿到"),_("code",[e._v("Observer")]),e._v("实例后，如果有新增元素，则使用"),_("code",[e._v("ob.observeArray")]),e._v("来侦测这些新增元素的变化。")]),e._v(" "),_("h1",{attrs:{id:"_13、关于array的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13、关于array的问题"}},[e._v("#")]),e._v(" 13、关于Array的问题")]),e._v(" "),_("p",[e._v("因为Vue对Array的变化侦测是"),_("strong",[e._v("通过拦截原型")]),e._v("的方式实现的，所以有些数组操作Vue.js是拦截不到的，比如：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("this.list[0] = 2\n")])])]),_("p",[e._v("修改数组中的第一个元素的值，无法检测到数组的变化，所以并不会触发"),_("code",[e._v("re-render")]),e._v("或"),_("code",[e._v("watch")])]),e._v(" "),_("p",[e._v("再例如：")]),e._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[e._v("this.list.length = 0;\n")])])]),_("p",[e._v("这个清空数组操作也无法侦测到数组的变化，所以也不会触发"),_("code",[e._v("re-render")]),e._v("或"),_("code",[e._v("watch")]),e._v("等。")]),e._v(" "),_("p",[e._v("因为"),_("code",[e._v("Vue.js")]),e._v("的实现方式决定了无法对上面举的两个例子做拦截，也就没有办法响应.")]),e._v(" "),_("p",[e._v("在ES6之前，无法做到模拟数组的原生行为，所以拦截不到也是没有办法的事情。")]),e._v(" "),_("p",[e._v("ES6提供了元编程的能力，所以有能力拦截，现在的"),_("code",[e._v("Vue3")]),e._v("就是使用ES6提供的"),_("code",[e._v("Proxy")]),e._v("来实现这部分功能，从而解决这个问题。")]),e._v(" "),_("h1",{attrs:{id:"_14、总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_14、总结"}},[e._v("#")]),e._v(" 14、总结")]),e._v(" "),_("p",[e._v("1、"),_("code",[e._v("Array")]),e._v("追踪变化的方式和"),_("code",[e._v("Object")]),e._v("不一样。")]),e._v(" "),_("ul",[_("li",[e._v("因为它是通过方法来改变内容的，所以我们通过创建拦截器去覆盖数组原型的方式来追踪变化。")])]),e._v(" "),_("p",[e._v("2、 为了不污染全局"),_("code",[e._v("Array.prototype")]),e._v("，我们在"),_("code",[e._v("Observer")]),e._v("中只针对那些需要侦测变化的数组使用 "),_("code",[e._v("__proto__")]),e._v("来覆盖原型方法")]),e._v(" "),_("ul",[_("li",[e._v("但 "),_("code",[e._v("__proto__")]),e._v("在ES6之前并不是标准属性，不是所有浏览器都支持它。")]),e._v(" "),_("li",[e._v("针对不支持"),_("code",[e._v("__proto__")]),e._v("属性的浏览器，我们直接循环拦截器，把拦截器中的方法直接设置到数组身上来拦截"),_("code",[e._v("Array.prototype")]),e._v("上的原生方法。")])]),e._v(" "),_("p",[e._v("3、"),_("code",[e._v("Array")]),e._v("收集依赖的方式和"),_("code",[e._v("Object")]),e._v("一样，都是在"),_("code",[e._v("getter")]),e._v("中收集。")]),e._v(" "),_("ul",[_("li",[e._v("由于使用依赖的位置不同，数组要在拦截器中向依赖发消息")]),e._v(" "),_("li",[e._v("所以依赖不能像"),_("code",[e._v("Object")]),e._v("那样保存在"),_("code",[e._v("defineReactive")]),e._v("中")]),e._v(" "),_("li",[e._v("而是把依赖保存在了"),_("code",[e._v("Observer")]),e._v("实例上。")])]),e._v(" "),_("p",[e._v("4、在"),_("code",[e._v("Observer")]),e._v("中，我们对每个侦测了变化的数据都标上印记"),_("code",[e._v("__ob__")]),e._v("，并把"),_("code",[e._v("this")]),e._v("（Observer实例）保存在 "),_("code",[e._v("__ob__")]),e._v("上。")]),e._v(" "),_("p",[e._v("主要作用：")]),e._v(" "),_("ul",[_("li",[e._v("为了标记数据是否被侦测了变化（保证同一个数据只被侦测一次）")]),e._v(" "),_("li",[e._v("可以很方便地通过数据取到"),_("code",[e._v("__ob__")]),e._v("，从而拿到"),_("code",[e._v("Observer")]),e._v("实例上保存的依赖。")]),e._v(" "),_("li",[e._v("当拦截到数组发生变化时，向依赖发送通知。")])]),e._v(" "),_("p",[e._v("5、除了侦测数组"),_("strong",[e._v("自身的变化")]),e._v("外，"),_("strong",[e._v("数组中元素发生的变化")]),e._v("也要侦测。")]),e._v(" "),_("ul",[_("li",[e._v("调用"),_("code",[e._v("observeArray")]),e._v("方法将数组中的每一个元素都转换成响应式的并侦测变化。")])]),e._v(" "),_("p",[e._v("6、除了侦测已有数据外，当用户使用"),_("code",[e._v("push")]),e._v("等方法向数组中"),_("strong",[e._v("新增数据")]),e._v("时，"),_("strong",[e._v("新增的数据也要进行变化侦测")]),e._v("。")]),e._v(" "),_("ul",[_("li",[e._v("如果是"),_("code",[e._v("push、unshift和splice")]),e._v("方法")])]),e._v(" "),_("ul",[_("li",[_("ul",[_("li",[e._v("从参数中将新增数据提取出来")]),e._v(" "),_("li",[e._v("然后使用"),_("code",[e._v("observeArray")]),e._v("对新增数据进行"),_("strong",[e._v("变化侦测")]),e._v("。")])])])]),e._v(" "),_("p",[e._v("7、由于在ES6之前，"),_("code",[e._v("JavaScript")]),e._v("并没有提供元编程的能力，所以对于数组类型的数据，一些语法无法追踪到变化。")]),e._v(" "),_("ul",[_("li",[e._v("只能拦截原型上的方法")]),e._v(" "),_("li",[e._v("无法拦截数组特有的语法")]),e._v(" "),_("li",[e._v("例如使用"),_("code",[e._v("length")]),e._v("清空数组的操作就无法拦截。")])])])}),[],!1,null,null,null);_.default=t.exports}}]);